# S1 â€” Solidity Smart Contracts

> **Status**: ðŸ”² TODO
> **Directory**: `contracts/`
> **Toolchain**: Foundry (forge, cast, anvil)

## Purpose

On-chain settlement contracts for Tier 3 (trustless) settlement. Deployed on EVM-compatible chains (Ethereum, Polygon, Arbitrum).

## Contracts

### EscrowVault.sol
```solidity
contract EscrowVault {
    mapping(address => mapping(address => uint256)) public deposits;   // user â†’ token â†’ amount
    mapping(address => mapping(address => uint256)) public frozen;     // user â†’ token â†’ frozen
    mapping(bytes32 => bool) public settledTrades;                     // trade_id â†’ settled

    function deposit(address token, uint256 amount) external;
    function withdraw(address token, uint256 amount) external;
    function freeze(bytes32 orderId, address token, uint256 amount) external;
    function unfreeze(bytes32 orderId, address token, uint256 amount) external;

    /// Settle a batch of trades atomically
    function settleBatch(BatchSettlement[] calldata settlements) external;

    struct BatchSettlement {
        bytes32 tradeId;
        address buyer;
        address seller;
        address baseToken;
        address quoteToken;
        uint256 baseAmount;
        uint256 quoteAmount;
        bytes32 matchProofHash;
        bytes[] nodeSignatures;    // M-of-N required
    }
}
```

### BatchVerifier.sol
```solidity
contract BatchVerifier {
    mapping(address => bool) public registeredNodes;
    uint256 public requiredSignatures;  // M of N

    function verifyMatchProof(
        bytes32 batchHash,
        bytes32 resultHash,
        bytes[] calldata signatures
    ) external view returns (bool);

    function registerNode(address node) external onlyOwner;
    function removeNode(address node) external onlyOwner;
}
```

### ArbitrationContract.sol
```solidity
contract Arbitration {
    uint256 public challengeWindow = 7 days;

    function submitFraudProof(
        bytes32 tradeId,
        bytes calldata freezeProof,
        bytes calldata matchProof,
        bytes calldata evidence
    ) external;

    function resolveDispute(bytes32 tradeId) external;  // after challenge window
    function slashNode(address node) external;            // for proven fraud
}
```

## Directory Structure
```
contracts/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ EscrowVault.sol
â”‚   â”œâ”€â”€ BatchVerifier.sol
â”‚   â””â”€â”€ ArbitrationContract.sol
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ EscrowVault.t.sol
â”‚   â”œâ”€â”€ BatchVerifier.t.sol
â”‚   â””â”€â”€ Integration.t.sol
â”œâ”€â”€ script/
â”‚   â””â”€â”€ Deploy.s.sol
â””â”€â”€ foundry.toml
```

## Rust Integration

- `openmatch-settlement` uses `ethers-rs` to call these contracts
- ABI generated by `forge build`, loaded in Rust via `abigen!` macro
- Contract addresses configured in `openmatch.toml`

## Testing

1. `forge test`: unit tests for each contract
2. Settlement cycle: deposit â†’ freeze â†’ match â†’ settleBatch â†’ verify balances
3. Fraud proof: submit evidence â†’ challenge window â†’ resolution
4. M-of-N signatures: verify threshold enforcement
5. Anvil (local testnet) for integration tests with Rust
